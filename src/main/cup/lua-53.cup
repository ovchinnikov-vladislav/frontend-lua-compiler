package ic7cc.ovchinnikov.compiler.parser;


import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import ic7cc.ovchinnikov.compiler.ast.*;
import ic7cc.ovchinnikov.compiler.ast.node.*;
import ic7cc.ovchinnikov.compiler.parser.location.*;
import ic7cc.ovchinnikov.compiler.parser.grammar.*;

import ic7cc.ovchinnikov.compiler.lexer.Lexer;

scan with {: return lexer.next_token(); :};

parser code {:
  public boolean syntaxErrors;
  DefaultProductionRuleBroadcaster productionRuleBroadcaster;
  Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    productionRuleBroadcaster = new DefaultProductionRuleBroadcaster();

    symbolFactory = lex.getSymbolFactory();

    lexer = lex;

  }

  public int line, column;

  public void report_error(String message, Object info) {
    syntaxErrors = true;

    if (!(info instanceof Symbol) ) return;

    Symbol symbol = (Symbol) info;
    line = symbol.left;
    column = symbol.right;

    if (symbol.left < 0 || symbol.right < 0) return;

    System.out.println(message + " at line " + symbol.left + ", column " + symbol.right);
  }
:};

/* Терминалы (токены, которые будут прочитаны лексером). */

terminal ASSIGNMENT;                                        // =
terminal DOT, COLON;                                        // операция точки и двоеточие
terminal LOCAL, FUNCTION, END;
terminal DO, WHILE, FOR, IN, REPEAT, UNTIL;                 // циклические операторы
terminal IF, THEN, ELSE, ELSEIF, RETURN, BREAK;             // операторы управления выполнением кода
terminal NIL, FALSE, TRUE, PARAMS;                          // зарезервированные литералы
terminal ADD, MUL, SUB, DIV, FDIV, MOD, POW, CONCAT;        // арифметические операторы и оператор конкатенации
terminal EQUAL, LESSEQ, NOTEQ, LESS, MORE, MOREEQ, AND, OR; // операторы отношения
terminal BAND, BOR, BRIGHT, BLEFT, BXOR;                    // побитовые операторы
terminal NOT, LENGTH;                                       // унарные операторы
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;// скобки
terminal SEMICOLON, COMMA;                                  // точка с запятой и запятая
terminal Double NUMERAL;                                    // Числовой литерал
terminal String LITERAL_STRING;                             // Строковый литерал
terminal String NAME;                                       // Идентификаторы

 /*Нетерминалы */

non terminal Block block, elselist;
non terminal StatList statlist;
non terminal RetStat retstat;
non terminal Stat stat;

non terminal VarList varlist;
non terminal ExpList explist, args, assignexplist;
non terminal FunctionCall functioncall;
non terminal Exp exp, comforexp;
non terminal NameList namelist;
non terminal FuncName funcname;
non terminal FuncBody funcbody;
non terminal Var var;
non terminal expadditlist;
non terminal PrefixExp prefixexp;
non terminal TableConstructor tableconstructor;
non terminal Operation binop;
non terminal Operation unop;
non terminal ParList parlist;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal fieldsep;
non terminal empty;

// Приоритеты
precedence nonassoc LPAREN, RPAREN;
precedence nonassoc COMMA;

precedence left OR;
precedence left AND;
precedence left BOR;
precedence left BAND;
precedence left EQUAL, NOTEQ;
precedence left LESSEQ, LESS, MORE, MOREEQ;
precedence left BRIGHT, BLEFT;
precedence left ADD, SUB, CONCAT;
precedence left MUL, DIV, MOD;
precedence right POW;
precedence left LENGTH;

/* Продукции грамматики */

start with block;

block ::=  statlist:sl retstat:rs   {:
                                        System.out.println("Block with statlist and retstat");
                                        RESULT = new Block(sl, rs);
                                    :}
         | statlist:sl              {:
                                        System.out.println("Block with statlist");
                                        RESULT = new Block(sl, null);
                                    :}
         | retstat:rs               {:
                                        System.out.println("Block with retstat");
                                        StatList sl = new StatList();
                                        sl.setStart(rs.getStart());
                                        sl.setEnd(rs.getStart());
                                        RESULT = new Block(sl, rs);
                                    :}
         | empty                    {:
										StatList statlist = new StatList();
										statlist.setStart(LocationFactory.from(null));
										statlist.setEnd(LocationFactory.from(null));
										System.out.println("Empty block");
										RESULT = new Block(statlist, null);
                                    :}
         ;

statlist ::=  stat:s			    {:
									    System.out.println("Single stat");
									    RESULT = new StatList(s);
								    :}
            | stat:s statlist:sl    {:
                                        System.out.println("Recurrent stat");
									    if (sl == null) {
										    sl = new StatList(s);
										    RESULT = sl;
		                                } else {
		                                    sl.addStat(0, s);
		                                    RESULT = sl;
		                                }

								    :}
            ;

stat ::=  SEMICOLON                                                 {:
                                                                        System.out.println("SEMICOLON");
                                                                    :}
        | varlist:vl ASSIGNMENT explist:el                          {:
                                                                        System.out.println("stat");
                                                                        RESULT = new Assignment(vl, el);
                                                                    :}
        | functioncall:fc                                           {:  RESULT = new FuncCallStatement(fc); :}
        | BREAK                                                     {:  RESULT = new Break(); :}
        | DO block:b END                                            {:
                                                                        System.out.println("stat - do end");
                                                                        RESULT = new DoBlock(b);
                                                                    :}
        | WHILE exp:e DO block:b END                                {:  RESULT = new WhileBlock(e, b); :}
        | REPEAT block:b UNTIL exp:e                                {:  RESULT = new RepeatUntil(b, e); :}
        | IF exp:e THEN block:b elselist:elsel END                  {:  RESULT = new IfThenElseBlock(e, b, elsel); :}
        | FOR NAME:name ASSIGNMENT exp:e1 COMMA exp:e2 comforexp:e3 DO block:b END {:   RESULT = new ForBlock(name, e1, e2, e3, b);  :}
        | FOR namelist:nl IN explist:el DO block:b END              {:  RESULT = new ForInBlock(nl, el, b);  :}
        | FUNCTION funcname:fn funcbody:fb                          {:
                                                                        VarList vl = FuncSyntactic.funcNameToVarList(fn);
                                                                        vl.setStart(fn.getStart());
                                                                        vl.setEnd(fn.getEnd());

                                                                        ExpList args = FuncSyntactic.methodDefinitionToExpression(fn, fb);
                                                                        args.setStart(fb.getStart());
                                                                        args.setEnd(fb.getEnd());

                                                                        Assignment asm = new Assignment(vl, args);

                                                                        RESULT = asm;
                                                                    :}
        | LOCAL FUNCTION NAME:name funcbody:fb                      {:  RESULT = new LocalFunctionDef(name, fb.getArgs(), fb.getVarArgs(), fb.getBlock()); :}
        | LOCAL namelist:nl assignexplist:el                        {:  RESULT = new LocalDecl(nl, el); :}
        ;

elselist ::=  ELSEIF exp:e THEN block:b elselist:elsel     {:  RESULT = new Block(new StatList(new IfThenElseBlock(e, b, elsel)), null);   :}
            | ELSE block:b                                 {:  RESULT = b;  :}
            | empty
            ;

comforexp ::=  COMMA exp:e                                 {:  RESULT = e;  :}
             | empty                                       {:  RESULT = new NumeralExp(1.0); :}
             ;

assignexplist ::=  ASSIGNMENT explist:el                   {:  RESULT = el; :}
                 | empty
                 ;

retstat ::=  RETURN explist:el SEMICOLON         {:  RESULT = new Return(el); :}
           | RETURN explist:el                   {:  RESULT = new Return(el); :}
           | RETURN SEMICOLON                    {:  RESULT = new Return(null); :}
           | RETURN                              {:  RESULT = new Return(null); :}
           ;

funcname ::=  NAME:name                          {:  RESULT = new FuncNameVar(new Name(name)); :}
            | NAME:name1 COLON NAME:name2        {:  RESULT = new FuncNameColonVar(new Name(name1), new Name(name2)); :}
            | NAME:name DOT funcname:fn          {:  RESULT = new FuncNameVarDotFuncName(new Name(name), fn); :}
            ;

varlist ::=  var:v                               {:  RESULT = new VarList(v); :}
           | var:v COMMA varlist:vl              {:
                                                     if (vl == null) {
                                                        vl = new VarList(v);
                                                        RESULT = vl;
                                                     } else {
                                                        vl.addVar(0, v);
                                                        RESULT = vl;
                                                     }
                                                 :}
           ;

var ::=  NAME:name                              {:  RESULT = new Variable(name); :}
       | prefixexp:pe LBRACKET exp:e RBRACKET   {:  RESULT = new VarTabIndex(pe, e); :}
       | prefixexp:pe DOT NAME:name             {:  RESULT = new VarTabIndex(pe,  new LiteralStringExp(name)); :}
       ;

namelist ::=  NAME:name                         {:  RESULT = new NameList(new Name(name)); :}
            | namelist:nl COMMA NAME:name       {:  nl.append(new Name(name)); RESULT = nl; :}
            ;

explist ::=  exp:e                          {:  RESULT = new ExpList(e); :}
           | exp:e COMMA explist:el         {:
                                                if (el == null) {
                                                    el = new ExpList(e);
                                                    RESULT = el;
                                                } else {
                                                    el.addExp(0, e);
                                                    RESULT = el;
                                                }
                                            :}
           ;

exp	::=	 NIL                                {:  RESULT = new Nil(); :}
	   | FALSE                              {:  RESULT = new BooleanExp(false); :}
	   | TRUE                               {:  RESULT = new BooleanExp(true);  :}
	   | NUMERAL:num                        {:  RESULT = new NumeralExp(num);    :}
	   | LITERAL_STRING:s                   {:  RESULT = new LiteralStringExp(s); :}
	   | PARAMS                             {:  RESULT = new Dots();   :}
	   | FUNCTION funcbody:fb               {:  RESULT = new FunctionExp(fb.getArgs(), fb.getVarArgs(), fb.getBlock()); :}
	   | prefixexp:pe                       {:  RESULT = new PreExp(pe); :}
	   | tableconstructor:tc                {:  RESULT = new TableConstructorExp(tc); :}
       | exp:e1 binop:op exp:e2             {:  RESULT = new Binop(e1, op, e2); :}
	   | unop:op exp:e                      {:  RESULT = new Unop(op, e); :}
	   ;

prefixexp ::=  var:v                            {:
                                                    System.out.println("Prefixexp var");
                                                    RESULT = new PrefixExpVar(v);
                                                :}
             | functioncall:fc                  {:
                                                    System.out.println("Prefixexp");
                                                    RESULT = new PrefixExpFuncCall(fc);
                                                :}
             | LPAREN exp:e RPAREN              {:
                                                    RESULT = new PrefixExpExp(e);
                                                :}
             ;

functioncall ::=  prefixexp:pexp args:ar                  {:  RESULT = new FuncCall(pexp, ar); :}
                | prefixexp:pexp COLON NAME:name args:ar  {:  RESULT = new FuncCallSelf(pexp, name, ar); :}
                ;

args ::=  LPAREN explist:el RPAREN                        {:  RESULT = el; :}
        | LPAREN RPAREN                                   {:  RESULT = new ExpList(null); :}
        | tableconstructor:tc                             {:  RESULT = new ExpList(new TableConstructorExp(tc)); :}
        | LITERAL_STRING:s                                {:  RESULT = new ExpList(new LiteralStringExp(s)); :}
        ;

funcbody ::=  LPAREN parlist:pl RPAREN block:b END        {:  RESULT = new FuncBody(pl, b); :}
            ;

parlist ::=  namelist:nl COMMA PARAMS                     {:  RESULT = new ParList(nl, true);  :}
           | namelist:nl                                  {:  RESULT = new ParList(nl, false); :}
           | PARAMS                                       {:
                                                              NameList nl = new NameList();
                                                              nl.setStart(LocationFactory.from(null));
                                                              nl.setEnd(LocationFactory.from(null));
                                                              RESULT = new ParList(nl, true);
                                                          :}
           |                                              {:
                                                              NameList nl = new NameList();
                                                              nl.setStart(LocationFactory.from(null));
                                                              nl.setEnd(LocationFactory.from(null));
                                                              RESULT = new ParList(nl, false);
                                                          :}
           ;

tableconstructor ::=  LBRACE fieldlist:fl RBRACE          {:  RESULT = new TableConstructor(fl); :}
                    | LBRACE RBRACE                       {:  RESULT = new TableConstructor(new FieldList()); :}
                    ;

fieldlist ::=  field:f fieldsep fieldlist:fl              {:
                                                              if (fl == null) {
                                                                  RESULT = new FieldList(f);
                                                              } else {
                                                                  fl.addField(0, f);
                                                                  RESULT = fl;
                                                              }
                                                          :}
             | field:f                                    {:  RESULT = new FieldList(f); :}
             ;

field ::=  LBRACKET exp:e1 RBRACKET ASSIGNMENT exp:e2     {:  RESULT = new FieldLeftRightExp(e1, e2); :}
         | NAME:name ASSIGNMENT exp:e                     {:  RESULT = new FieldNameExp(name, e); :}
         | exp:e                                          {:  RESULT = new FieldExp(e); :}
         ;

fieldsep ::=  COMMA
            | SEMICOLON
            ;

binop ::=  ADD      {: RESULT = Operation.ADD; :}
		 | SUB      {: RESULT = Operation.SUB; :}
		 | MUL      {: RESULT = Operation.MUL; :}
		 | DIV      {: RESULT = Operation.DIV; :}
		 | FDIV     {: RESULT = Operation.FDIV; :}
		 | MOD      {: RESULT = Operation.MOD; :}
		 | POW      {: RESULT = Operation.POW; :}
		 | CONCAT   {: RESULT = Operation.CONCAT; :}
		 | EQUAL    {: RESULT = Operation.EQUAL; :}
		 | LESSEQ   {: RESULT = Operation.LESSEQ; :}
		 | NOTEQ    {: RESULT = Operation.NOTEQ; :}
		 | LESS     {: RESULT = Operation.LESS; :}
		 | MORE     {: RESULT = Operation.MORE; :}
		 | MOREEQ   {: RESULT = Operation.MOREEQ; :}
		 | AND      {: RESULT = Operation.AND; :}
		 | OR       {: RESULT = Operation.OR; :}
		 | BAND     {: RESULT = Operation.BAND; :}
		 | BOR      {: RESULT = Operation.BOR; :}
		 | BRIGHT   {: RESULT = Operation.BRIGHT; :}
		 | BLEFT    {: RESULT = Operation.BLEFT; :}
		 | BXOR     {: RESULT = Operation.BXOR; :}
		 ;

unop ::=  SUB       {: RESULT = Operation.UNMINUS; :}
		| NOT       {: RESULT = Operation.NOT; :}
		| LENGTH    {: RESULT = Operation.LENGTH; :}
		| BXOR      {: RESULT = Operation.BNOT; :}
		;

empty ::= /* empty */;