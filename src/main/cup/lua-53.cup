package ic7cc.ovchinnikov.compiler.parser;


import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.*;
import ic7cc.ovchinnikov.compiler.ast.*;
import ic7cc.ovchinnikov.compiler.ast.node.*;
import ic7cc.ovchinnikov.compiler.parser.location.*;
import ic7cc.ovchinnikov.compiler.parser.grammar.*;

import ic7cc.ovchinnikov.compiler.lexer.Lexer;

scan with {: return lexer.next_token(); :};

parser code {:
  public boolean syntaxErrors;
  DefaultProductionRuleBroadcaster productionRuleBroadcaster;
  Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    productionRuleBroadcaster = new DefaultProductionRuleBroadcaster();

    symbolFactory = lex.getSymbolFactory();

    lexer = lex;

  }

  public int line, column;

  public void report_error(String message, Object info) {
    syntaxErrors = true;

    if (!(info instanceof Symbol) ) return;

    Symbol symbol = (Symbol) info;
    line = symbol.left;
    column = symbol.right;

    if (symbol.left < 0 || symbol.right < 0) return;

    System.out.println(message + " at line " + symbol.left + ", column " + symbol.right);
  }
:};

/* Терминалы (токены, которые будут прочитаны лексером). */

terminal ASSIGNMENT;                                        // =
terminal DOT, COLON;                                        // операция точки и двоеточие
terminal LOCAL, FUNCTION, END;
terminal DO, WHILE, FOR, IN, REPEAT, UNTIL;                 // циклические операторы
terminal IF, THEN, ELSE, ELSEIF, RETURN, BREAK;             // операторы управления выполнением кода
terminal NIL, FALSE, TRUE, PARAMS;                          // зарезервированные литералы
terminal ADD, MUL, SUB, DIV, FDIV, MOD, POW, CONCAT;        // арифметические операторы и оператор конкатенации
terminal EQUAL, LESSEQ, NOTEQ, LESS, MORE, MOREEQ, AND, OR; // операторы отношения
terminal BAND, BOR, BRIGHT, BLEFT, BXOR;                    // побитовые операторы
terminal NOT, LENGTH;                                       // унарные операторы
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;// скобки
terminal SEMICOLON, COMMA;                                  // точка с запятой и запятая
terminal NUMERAL, LITERAL_STRING;                           // Числовой и строковый литералы
terminal String NAME;                                       // Идентификаторы

 /*Нетерминалы */

non terminal Block block, elselist;
non terminal StatList statlist;
non terminal RetStat retstat;
non terminal Stat stat;

non terminal VarList varlist;
non terminal ExpList explist, args, assignexplist;
non terminal FunctionCall functioncall;
non terminal Exp exp, comforexp;
non terminal NameList namelist;
non terminal FuncName funcname;
non terminal FuncBody funcbody;
non terminal Var var;
non terminal nameadditlist;
non terminal expadditlist;
non terminal PrefixExp prefixexp;
non terminal TableConstructor tableconstructor;
non terminal Operation binop;
non terminal Operation unop;
non terminal ParList parlist;
non terminal FieldList fieldlist;
non terminal Field field;
non terminal fieldadditlist;
non terminal fieldsep;
non terminal empty;

// Приоритеты
precedence nonassoc LPAREN, RPAREN;
precedence nonassoc COMMA;

precedence left OR;
precedence left AND;
precedence left BOR;
precedence left BAND;
precedence left EQUAL, NOTEQ;
precedence left LESSEQ, LESS, MORE, MOREEQ;
precedence left BRIGHT, BLEFT;
precedence left ADD, SUB, CONCAT;
precedence left MUL, DIV, MOD;
precedence right POW;
precedence left LENGTH;

/* Продукции грамматики */

start with block;

block ::=  statlist:sl retstat:rs   {:
                                        System.out.println("Block with statlist and retstat");
                                        RESULT = new Block(sl, rs);
                                    :}
         | statlist:sl              {:
                                        System.out.println("Block with statlist");
                                        RESULT = new Block(sl, null);
                                    :}
         | retstat:rs               {:
                                        System.out.println("Block with retstat");
                                        StatList sl = new StatList();
                                        sl.setStart(rs.getStart());
                                        sl.setEnd(rs.getStart());
                                        RESULT = new Block(sl, rs);
                                    :}
         | empty                    {:
										StatList statlist = new StatList();
										statlist.setStart(LocationFactory.from(null));
										statlist.setEnd(LocationFactory.from(null));
										System.out.println("Empty block");
										RESULT = new Block(statlist, null);
                                    :}
         ;

statlist ::=  stat:s			    {:
									    System.out.println("Single stat");
									    RESULT = new StatList(s);
								    :}
            | stat:s statlist:sl    {:
                                        System.out.println("Recurrent stat");
									    if (sl == null) {
										    sl = new StatList(s);
										    RESULT = sl;
		                                } else {
		                                    sl.addStat(0, s);
		                                    RESULT = sl;
		                                }

								    :}
            ;

stat ::=  SEMICOLON                                                 {:
                                                                        System.out.println("SEMICOLON");
                                                                    :}
        | varlist:vl ASSIGNMENT explist:el                          {:
                                                                        System.out.println("stat");
                                                                        RESULT = new Assignment(vl, el);
                                                                    :}
        | functioncall:fc                                           {:  RESULT = new FuncCallStatement(fc); :}
        | BREAK                                                     {:  RESULT = new Break(); :}
        | DO block:b END                                            {:
                                                                        System.out.println("stat - do end");
                                                                        RESULT = new DoBlock(b);
                                                                    :}
        | WHILE exp:e DO block:b END                                {:  RESULT = new WhileBlock(e, b); :}
        | REPEAT block:b UNTIL exp:e                                {:  RESULT = new RepeatUntil(b, e); :}
        | IF exp:e THEN block:b elselist:elsel END                  {:  RESULT = new IfThenElseBlock(e, b, elsel); :}
        | FOR NAME:name ASSIGNMENT exp:e1 COMMA exp:e2 comforexp:e3 DO block:b END {:   RESULT = new ForBlock(name, e1, e2, e3, b);  :}
        | FOR namelist:nl IN explist:el DO block:b END              {:  RESULT = new ForInBlock(nl, el, b);  :}
        | FUNCTION funcname:fn funcbody:fb                          {:
                                                                        VarList vl = FuncSyntactic.funcNameToVarList(fn);
                                                                        vl.setStart(fn.getStart());
                                                                        vl.setEnd(fn.getEnd());

                                                                        ExpList args = FuncSyntactic.methodDefinitionToExpression(fn, fb);
                                                                        args.setStart(fb.getStart());
                                                                        args.setEnd(fb.getEnd());

                                                                        Assignment asm = new Assignment(vl, args);

                                                                        RESULT = asm;
                                                                    :}
        | LOCAL FUNCTION NAME:name funcbody:fb                      {:  RESULT = new LocalFunctionDef(name, fb.getArgs(), fb.getVarArgs(), fb.getBlock()); :}
        | LOCAL namelist:nl assignexplist:el                        {:  RESULT = new LocalDecl(nl, el); :}
        ;

elselist ::=  ELSEIF exp THEN block elselist
            | ELSE block
            | empty
            ;

comforexp ::=  COMMA exp
             | empty
             ;

assignexplist ::=  ASSIGNMENT explist
                 | empty
                 ;

retstat ::=  RETURN explist:el SEMICOLON         {:  RESULT = new Return(el); :}
           | RETURN explist:el                   {:  RESULT = new Return(el); :}
           | RETURN SEMICOLON                    {:  RESULT = new Return(null); :}
           | RETURN                              {:  RESULT = new Return(null); :}
           ;

funcname ::=  NAME:name                          {:  RESULT = new FuncNameVar(new Name(name)); :}
            | NAME:name1 COLON NAME:name2        {:  RESULT = new FuncNameColonVar(new Name(name1), new Name(name2)); :}
            | NAME:name DOT funcname:fn          {:  RESULT = new FuncNameVarDotFuncName(new Name(name), fn); :}
            ;

varlist ::=  var
           | var COMMA varlist
           ;

var ::=  NAME
       | prefixexp LBRACKET exp RBRACKET
       | prefixexp DOT NAME
       ;

namelist ::= NAME nameadditlist;

nameadditlist ::=  COMMA NAME nameadditlist
                 | empty
                 ;

explist ::= exp expadditlist;

exp	::=	 NIL
	   | FALSE
	   | TRUE
	   | NUMERAL
	   | LITERAL_STRING
	   | PARAMS
	   | FUNCTION funcbody // functiondef
	   | prefixexp
	   | tableconstructor
       | exp binop exp
	   | unop exp
	   ;

expadditlist ::=  COMMA exp expadditlist
                | empty
                ;

prefixexp ::=  var:v                            {:
                                                    System.out.println("Prefixexp var");
                                                    RESULT = new PrefixExpVar(v);
                                                :}
             | functioncall:fc                  {:
                                                    System.out.println("Prefixexp");
                                                    RESULT = new PrefixExpFuncCall(fc);
                                                :}
             | LPAREN exp:e RPAREN              {:
                                                    RESULT = new PrefixExpExp(e);
                                                :}
             ;

functioncall ::=  prefixexp args
                | prefixexp COLON NAME args
                ;

args ::=  LPAREN explist RPAREN
        | LPAREN RPAREN
        | tableconstructor
        | LITERAL_STRING
        ;

funcbody ::=  LPAREN parlist RPAREN block END
            | LPAREN RPAREN block END
            ;

parlist ::=  namelist COMMA PARAMS
           | namelist
           | PARAMS;

tableconstructor ::=  LBRACE fieldlist RBRACE
                    | LBRACE RBRACE;

fieldlist ::=  field fieldadditlist fieldsep
             | field fieldadditlist
             ;

field ::=  LBRACKET exp RBRACKET ASSIGNMENT exp
         | NAME ASSIGNMENT exp
         | exp
         ;

fieldsep ::=  COMMA
            | SEMICOLON
            ;

fieldadditlist ::=  fieldsep field fieldadditlist
                  | empty
                  ;

binop ::=  ADD
		 | SUB
		 | MUL
		 | DIV
		 | FDIV
		 | MOD
		 | POW
		 | CONCAT
		 | EQUAL
		 | LESSEQ
		 | NOTEQ
		 | LESS
		 | MORE
		 | MOREEQ
		 | AND
		 | OR
		 | BAND
		 | BOR
		 | BRIGHT
		 | BLEFT
		 | BXOR
		 ;

unop ::=  SUB
		| NOT
		| LENGTH
		| BXOR
		;

empty ::= /* empty */;