package ic7cc.ovchinnikov.compiler.parser;

import java_cup.runtime.*;


/* August 1999 - modified by Gerwin Klein <lsf@jflex.de>
                 to interface with JFlex scanners,
                 allows empty semicolon in class decls.
  
  changed productions:

  class_member_declaration ::=
	  	field_declaration
  	|	method_declaration
    [..]
  	|	interface_declaration
    | SEMICOLON
  	;

  interface_member_declaration ::=
  		constant_declaration
	  |	abstract_method_declaration
  	|	class_declaration
  	|	interface_declaration
    | SEMICOLON
	  ;

*/


/* Java 1.2 parser for CUP.  
 * Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 * This program is released under the terms of the GPL; see the file
 * COPYING for more details.  There is NO WARRANTY on this code.
 */

/*
JDK 1.2 Features added:
  strictfp modifier.
  explicit_constructor_invocation ::= ...
        | primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON ;
  field_access ::= ...
        |       name DOT SUPER DOT IDENTIFIER ;
  method_invocation ::= ...
        |       name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN ;
*/

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal SEMICOLON; // `;`
terminal EQ; // `=`
terminal BREAK;
terminal DO;
terminal END;
terminal WHILE;
terminal REPEAT;
terminal UNTIL;
terminal IF;
terminal THEN;
terminal ELSEIF;
terminal ELSE;
terminal FOR;
terminal COMMA; // `,`
terminal IN;
terminal FUNCTION;
terminal LOCAL;
terminal RETURN;
terminal COLONCOLON; // `::`
terminal DOT; // `.`
terminal COLON; // `:`
terminal LBRACKET; // `[`
terminal RBRACKET; // `]`
terminal NIL;
terminal FALSE;
terminal TRUE;
terminal PARAMS; // `...`
terminal LPAREN; // `(`
terminal RPAREN; // `)`
terminal LBRACE; // `{`
terminal RBRACE; // `}`
terminal PLUS; // `+`
terminal MINUS; // `-`
terminal MULTIPLICATION; // `*`
terminal DIVISION; // `/`
terminal EXPONENTIATION; // `^`
terminal MOD; // `%`
terminal BITWISEAND; // `&`
terminal BITWISENOT; // `~`
terminal BITWISEOR; // `|`
terminal BITWISERIGHT; // `>>`
terminal BITWISELEFT; // `<<`
terminal CONCAT; // `..`
terminal LESS; // `<`
terminal LESSEQ; // `<=`
terminal MORE; // `>`
terminal MOREEQ; // `>=`
terminal EQEQ; // `==`
terminal NOTEQ; // `~=`
terminal AND;
terminal OR;
terminal NOT;
terminal LATTICE; // `#`
terminal NUMBER;
terminal STRING;

// Объявлено, но не используется
terminal GOTO;

non terminal chunk;
non terminal block;
non terminal stat;
non terminal statlist;
non terminal retstat;
non terminal varlist;
non terminal explist;
non terminal functioncall;
non terminal label;
non terminal Name;
non terminal exp;
non terminal namelist;
non terminal funcname;
non terminal funcbody;
non terminal var;
non terminal prefixexp;
non terminal functiondef;
non terminal tableconstructor;
non terminal binop;
non terminal unop;
non terminal args;
non terminal parlist;
non terminal fieldlist;
non terminal field;
non terminal fieldsep;
non terminal optsemi;


start with chunk;

chunk ::= block;

block ::= statlist retstat
        | statlist
        | retstat
        | empty;

statlist ::=  stat optsemi
            | stat optsemi statlist;

retstat ::=   RETURN optsemi
            | RETURN explist optsemi
            | BREAK optsemi;

stat ::=  SEMICOLON
        | varlist EQ explist
        | functioncall
        | label
        | BREAK
        | DO block END
        | WHILE exp DO block END
        | REPEAT block UNTIL exp
        | IF exp THEN BLOCK optelse END
        | FOR Name EQ exp COMMA exp optforexp DO block END
        | FOR namelist IN explist DO block END
        | FUNCTION funcname funcbody
        | LOCAL FUNCTION Name funcbody
        | LOCAL namelist opteqexplist;

varlist ::=  var
           | var COMMA varlist;

explist ::=  exp
           | exp COMMA explist;

functioncall ::=  prefixexp args
                | prefixexp COLON Name args;

label ::= COLONCOLON Name COLONCOLON;

exp ::=  NIL
       | FALSE
       | TRUE
       | NUMBER
       | STRING
       | PARAMS
       | functiondef
       | prefixexp
       | tableconstructor
       | exp binop exp
       | unop exp;

optelse ::=  ELSE block
           | ELSEIF exp THEN block optelse
           | empty;

optforexp ::=  COMMA exp
             | empty;

namelist ::=  Name
            | namelist COMMA Name;

funcname ::=  Name
            | Name DOT funcname
            | Name COLON Name;

funcbody ::= LPAREN parlist RPAREN block END;

opteqexplist ::=  EQ explist
                | empty;

var ::=  Name
       | prefixexp LBRACKET exp RBRACKET
       | prefixexp DOT Name;

prefixexp ::=  var
             | functioncall
             | LPAREN exp RPAREN;

args ::=  LPAREN explist RPAREN
        | LPAREN RPAREN
        | tableconstructor
        | STRING;

functiondef ::= FUNCTION funcbody;

tableconstructor ::=  LBRACE fieldlist RBRACE
                    | LBRACE RBRACE;

binop ::=  PLUS
         | MINUS
         | MULTIPLICATION
         | DIVISION
         | EXPONENTIATION
         | MOD
         | BITWISEAND
         | BITWISENOT
         | BITWISEOR
         | BITWISERIGHT
         | BITWISELEFT
         | CONCAT
         | LESS
         | LESSEQ
         | MORE
         | MOREEQ
         | EQEQ
         | NOTEQ
         | AND
         | OR;

unop ::=  MINUS
        | NOT
        | LATTICE;

parlist ::=  namelist
           | namelist COMMA PARAMS
           | PARAMS;

fieldlist ::=  field
             | field fieldsep fieldlist;

field ::=  LBRACKET exp RBRACKET EQ exp
         | Name EQ exp
         | exp;

fieldsep ::=  COMMA
            | SEMICOLON;

optsemi	::=  SEMI
           | empty;

empty ::= /* empty */;